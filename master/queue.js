import { existsSync } from "fs";
import fs from "fs/promises";
export { savePendingQueue, addCustomerQueue, removeCustomerQueue, getUserQueueHead, getTaskQueueHead, pendingQueueToFinishedQueue, loadPendingQueue, getTaskByUser, removeFinishedCustomerQueue };

// Start by creating needed queue arrays
let pendingUserQueue = [];
let pendingTaskQueue = [];
let finishedUserQueue = [];
let finishedTaskQueue = [];

async function addCustomerQueue(user, task) {
    await loadPendingQueue();
    pendingUserQueue.push(user);
    pendingTaskQueue.push(task);
    await savePendingQueue();
}

async function removeCustomerQueue() {
    await loadPendingQueue();
    pendingUserQueue.shift();
    pendingTaskQueue.shift();
    await savePendingQueue();
}

async function getUserQueueHead() {
    await loadPendingQueue();
    if (pendingUserQueue.length === 0) {
        return null;
    } else {
        return pendingUserQueue[0];
    }
}

async function removeFinishedCustomerQueue(index) {
    await loadFinishedQueue();
    finishedUserQueue.splice(index, 1);
    finishedTaskQueue.splice(index, 1);
    await saveFinishedQueue();
}

async function getTaskQueueHead() {
    await loadPendingQueue();
    if (pendingTaskQueue.length === 0) {
        return null;
    } else {
        return pendingTaskQueue[0];
    }
}

async function csvMaker(data) {    //Takes the data arrays that it is given and formats it into a CSV friendly format
    let csvRows = [];      //So that they can be downloaded to the server

    const headers = Object.keys(data);
    csvRows.push(headers.join(','));

    const values = Object.values(data).join('\n');
    csvRows.push(values);

    return csvRows.join('\n');
}

async function serverDownloadCsv(data, csvFileName) { //Helper fucntion to download the CSV friendly arrays to the server
    try {
        await fs.writeFile(`master/autogeneratedFiles/${csvFileName}.csv`, data, { encoding: 'utf8', flag: 'w' });
    } catch (err) {
        console.error(err);
    }
}

async function savePendingQueue() {      //Saves the pending queue to the server
    let pendingQueueData = {
        User: pendingUserQueue,
        Task: pendingTaskQueue
    }
    let csvPendingQueueFileName = "pendingQueue";
    let csvPendingQueueData = await csvMaker(pendingQueueData);
    await serverDownloadCsv(csvPendingQueueData, csvPendingQueueFileName);
}

async function saveFinishedQueue() {     //Save the Finished queue to the server
    let finishedQueueData = {
        User: finishedUserQueue,
        Task: finishedTaskQueue
    }
    let csvFinishedQueueFileName = "finishedQueue";
    let csvFinishedQueueData = await csvMaker(finishedQueueData);
    await serverDownloadCsv(csvFinishedQueueData, csvFinishedQueueFileName);
}

async function loadPendingQueue() {      //loads the pending queue from the server
    if (existsSync("master/autogeneratedFiles")) {
        if (existsSync("master/autogeneratedFiles/pendingQueue.csv")) {  //Checks if a pendingQueue.csv exists
            let csvData = await fs.readFile("master/autogeneratedFiles/pendingQueue.csv", 'utf8');
            let rows = csvData.split('\n');

            let rowOne = []; //We need to say tell the code that this is an array
            let rowTwo = []; //Otherwise it just thinks that it's a string

            rowOne = rows[1]; //We only need row 1 and 2, since row 0 is the header
            rowTwo = rows[2];

            if (rowOne !== undefined && rowOne !== '' && rowTwo !== undefined && rowTwo !== '') { //If the "rows" are empty 
                pendingUserQueue = rowOne.split(',');           //they will be undefined and split
                pendingTaskQueue = rowTwo.split(',');          //will therefor crash the server
            }

        } else {
            await fs.writeFile("master/autogeneratedFiles/pendingQueue.csv", "", { encoding: 'utf8', flag: 'w' });
        }                   //If no pendingQueue.csv exists it creates an empty one
    } else {
        await fs.mkdir("master/autogeneratedFiles");
        await fs.writeFile("master/autogeneratedFiles/pendingQueue.csv", "", { encoding: 'utf8', flag: 'w' });
    }
}

async function loadFinishedQueue() {      //loads the finished queue from the server
    if (existsSync("master/autogeneratedFiles")) {
        if (existsSync("master/autogeneratedFiles/finishedQueue.csv")) {  //Checks if a finishedQueue.csv exists
            let csvData = await fs.readFile("master/autogeneratedFiles/finishedQueue.csv", 'utf8');
            let rows = csvData.split('\n');

            let rowOne = []; //We need to say tell the code that this is an array
            let rowTwo = []; //Otherwise it just thinks that it's a string

            rowOne = rows[1]; //We only need row 1 and 2, since row 0 is the header
            rowTwo = rows[2];

            if (rowOne !== undefined && rowOne !== '' && rowTwo !== undefined && rowTwo !== '') { //If the "rows" are empty
                finishedUserQueue = rowOne.split(',');          //they will be undefined and split
                finishedTaskQueue = rowTwo.split(',');         //will therefor crash the server
            }

        } else {
            await fs.writeFile("master/autogeneratedFiles/finishedQueue.csv", "", { encoding: 'utf8', flag: 'w' });
        }                   //If no pendingQueue.csv exists it creates an empty one
    } else {
        await fs.mkdir("master/autogeneratedFiles");
        await fs.writeFile("master/autogeneratedFiles/finishedQueue.csv", "", { encoding: 'utf8', flag: 'w' });
    }
}

async function pendingQueueToFinishedQueue() {     //Takes the first element from the pending queeu and pushes it to the finished queue
    await loadPendingQueue();                    //Also saves the finished and pending queue in their updated version
    finishedUserQueue.push(await getUserQueueHead());
    finishedTaskQueue.push('sorted' + await getTaskQueueHead());
    await removeCustomerQueue();
    await saveFinishedQueue();
    await savePendingQueue();
}

async function getTaskByUser(user) {
    await loadPendingQueue();
    await loadFinishedQueue();
    let k = 0;
    let taskArrayForUser = [""];

    for (let i = 0; i < finishedUserQueue.length; i++) {
        if (user === finishedUserQueue[i]) {
            taskArrayForUser[k] = finishedTaskQueue[i];
            console.log(taskArrayForUser);
            k++;
        }
    }

    taskArrayForUser[k] = "Shift";
    k++;

    for (let i = 0; i < pendingUserQueue.length; i++) {
        if (pendingUserQueue[i] == user) {
            taskArrayForUser[k] = pendingTaskQueue[i];
            console.log(taskArrayForUser);
            k++;
        }
    }
    console.log(taskArrayForUser);
    return taskArrayForUser;
}