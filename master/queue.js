import { writeFileSync, existsSync, mkdirSync } from "fs";
import fs from "fs/promises";
export { savePendingQueue, addCustomerQueue, removeCustomerQueue, getUserQueueHead, getTaskQueueHead, pendingQueueToFinishedQueue, loadPendingQueue, getTaskByUser };

// Start by creating needed queue arrays
let pendingUserQueue = [""];
let pendingTaskQueue = [""];
let finishedUserQueue = [""];
let finishedTaskQueue = [""];

async function addCustomerQueue(user, task) {
    await loadPendingQueue();
    pendingUserQueue.push(user);
    pendingTaskQueue.push(task);
    await savePendingQueue();
}

async function removeCustomerQueue() {
    await loadPendingQueue();
    pendingUserQueue.shift();
    pendingTaskQueue.shift();
    await savePendingQueue();
}

async function getUserQueueHead() {
    await loadPendingQueue();
    if (pendingUserQueue.length === 0) {
        return console.log("User que is empty");
    } else {
        return pendingUserQueue[0];
    }
}

async function getTaskQueueHead() {
    await loadPendingQueue();
    if (pendingTaskQueue.length === 0) {
        return console.log("Task que is empty");
    } else {
        return pendingTaskQueue[0];
    }
}

async function csvMaker(data) {    //Takes the data arrays that it is given and formats it into a CSV friendly format
    let csvRows = [];      //So that they can be downloaded to the server

    const headers = Object.keys(data);
    csvRows.push(headers.join(','));

    const values = Object.values(data).join(',\n');
    csvRows.push(values);

    return csvRows.join('\n');
}

async function serverDownloadCsv(data, csvFileName) { //Helper fucntion to download the CSV friendly arrays to the server
    try {
        writeFileSync(`master/autoGeneratedFiles/${csvFileName}.csv`, data, { encoding: 'utf8', flag: 'w' });
    } catch (err) {
        console.error(err);
    }
}

async function savePendingQueue() {      //Saves the pending queue to the server
    let pendingQueueData = {
        User: pendingUserQueue,
        Task: pendingTaskQueue
    }
    let csvPendingQueueFileName = "pendingQueue";
    let csvPendingQueueData = await csvMaker(pendingQueueData);
    await serverDownloadCsv(csvPendingQueueData, csvPendingQueueFileName);
}

async function saveFinishedQueue() {     //Save the Finished queue to the server
    let finishedQueueData = {
        User: finishedUserQueue,
        Task: finishedTaskQueue
    }
    let csvFinishedQueueFileName = "finishedQueue";
    let csvFinishedQueueData = await csvMaker(finishedQueueData);
    await serverDownloadCsv(csvFinishedQueueData, csvFinishedQueueFileName);
}

async function loadPendingQueue() {      //loads the pending queue from the server
    if (existsSync("master/autoGeneratedFiles/pendingQueue.csv") && existsSync("master/autoGeneratedFiles")) {  //Checks if a pendingQueue.csv exists
        let csvData = await fs.readFile("master/autoGeneratedFiles/pendingQueue.csv", 'utf8');
        let rows = csvData.split('\n');

        let rowOne = ['']; //We need to say tell the code that this is an array
        let rowTwo = ['']; //Otherwise it just thinks that it's a string

        rowOne = rows[1]; //We only need row 1 and 2, since row 0 is the header
        rowTwo = rows[2];

        if (rowOne !== undefined || rowTwo !== undefined) { //If the "rows" are empty 
            pendingUserQueue = rowOne.split(',');           //they will be undefined and split
            pendingTaskQueue = rowTwo.split(',');          //will therefor crash the server
        }

    } else {
        mkdirSync("master/autoGeneratedFiles");
        writeFileSync("master/autoGeneratedFiles/pendingQueue.csv", "", { encoding: 'utf8', flag: 'w' });
    }                   //If no pendingQueue.csv exists it creates an empty one
}

async function loadFinishedQueue() {      //loads the finished queue from the server
    if (existsSync("master/autoGeneratedFiles")) {
        if (existsSync("master/autoGeneratedFiles/finishedQueue.csv")) {  //Checks if a finishedQueue.csv exists
            let csvData = await fs.readFile("master/autoGeneratedFiles/finishedQueue.csv", 'utf8');
            let rows = csvData.split('\n');

            let rowOne = ['']; //We need to say tell the code that this is an array
            let rowTwo = ['']; //Otherwise it just thinks that it's a string

            rowOne = rows[1]; //We only need row 1 and 2, since row 0 is the header
            rowTwo = rows[2];

            if (rowOne !== undefined || rowTwo !== undefined) { //If the "rows" are empty
                finishedUserQueue = rowOne.split(',');          //they will be undefined and split
                finishedTaskQueue = rowTwo.split(',');         //will therefor crash the server
            }

        } else {
            writeFileSync("master/autoGeneratedFiles/finishedQueue.csv", "", { encoding: 'utf8', flag: 'w' });
        }                   //If no pendingQueue.csv exists it creates an empty one
    } else {
        mkdirSync("master/autoGeneratedFiles");
    }
}

async function pendingQueueToFinishedQueue() {     //Takes the first element from the pending queeu and pushes it to the finished queue
    await loadPendingQueue();                    //Also saves the finished and pending queue in their updated version
    finishedUserQueue.push(getUserQueueHead());
    finishedTaskQueue.push(getTaskQueueHead());
    await removeCustomerQueue();
    await saveFinishedQueue();
    await savePendingQueue();
}

async function getTaskByUser(user) {
    await loadPendingQueue();
    await loadFinishedQueue();
    let k = 0;
    let taskArrayForUser = [""];

    for (let i = 0; i < finishedUserQueue.length; i++) {
        if (user === finishedUserQueue[i]) {
            taskArrayForUser[k] = finishedTaskQueue[i];
            k++;
        }
    }

    taskArrayForUser[k] = "Shift";
    k++;

    for (let i = 0; i <= pendingUserQueue.length; i++) {
        if (pendingUserQueue[i] == user) {
            taskArrayForUser[k] = pendingTaskQueue[i];
            k++;
        }
    }

    return taskArrayForUser;
}