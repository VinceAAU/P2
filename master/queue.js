import { existsSync } from "fs";
import fs from "fs/promises";
export { savePendingQueue, addCustomerQueue, removeCustomerQueue, getUserQueueHead, getTaskQueueHead, pendingQueueToFinishedQueue, loadPendingQueue, getTaskByUser, removeFinishedCustomerQueue, findFinishedTaskIndex, serverDownloadCsv, csvMaker };

// Start by creating needed queue arrays
let pendingUserQueue = [];
let pendingTaskQueue = [];
let finishedUserQueue = [];
let finishedTaskQueue = [];

async function addCustomerQueue(user, task) {
    await loadPendingQueue();
    pendingUserQueue.push(user);
    pendingTaskQueue.push(task);
    await savePendingQueue();
}

async function removeCustomerQueue() {
    await loadPendingQueue();
    pendingUserQueue.shift();
    pendingTaskQueue.shift();
    await savePendingQueue();
}

async function getUserQueueHead() {
    await loadPendingQueue();
    if (pendingUserQueue.length === 0) {
        return null;
    } else {
        return pendingUserQueue[0];
    }
}

async function removeFinishedCustomerQueue(index) {
    await loadFinishedQueue();
    finishedUserQueue.splice(index, 1);
    finishedTaskQueue.splice(index, 1);
    await saveFinishedQueue();
}

async function findFinishedTaskIndex(user, task)
{
    for(let i = 0; i < finishedTaskQueue.length; i++)
    {
        if(finishedTaskQueue[i] === task && finishedUserQueue[i] === user)
        {
            return i;
        }
    }
    console.log("Couldn't find user or task");
    return null;
}

async function getTaskQueueHead() {
    await loadPendingQueue();
    if (pendingTaskQueue.length === 0) {
        return null;
    } else {
        return pendingTaskQueue[0];
    }
}

async function csvMaker(data) { 
    let csvRows = [];      

    const headers = Object.keys(data);
    csvRows.push(headers.join(','));

    const values = Object.values(data).join('\n');
    csvRows.push(values);

    return csvRows.join('\n');
}

async function serverDownloadCsv(data, csvFileName) {
    try {
        await fs.writeFile(`master/autogeneratedFiles/${csvFileName}.csv`, data, { encoding: 'utf8', flag: 'w' });
    } catch (err) {
        console.error(err);
    }
}

async function savePendingQueue() {     
    let pendingQueueData = {
        User: pendingUserQueue,
        Task: pendingTaskQueue
    }
    let csvPendingQueueFileName = "pendingQueue";
    let csvPendingQueueData = await csvMaker(pendingQueueData);
    await serverDownloadCsv(csvPendingQueueData, csvPendingQueueFileName);
}

async function saveFinishedQueue() {     
    let finishedQueueData = {
        User: finishedUserQueue,
        Task: finishedTaskQueue
    }
    let csvFinishedQueueFileName = "finishedQueue";
    let csvFinishedQueueData = await csvMaker(finishedQueueData);
    await serverDownloadCsv(csvFinishedQueueData, csvFinishedQueueFileName);
}

async function loadPendingQueue() {      
    if (existsSync("master/autogeneratedFiles")) {
        if (existsSync("master/autogeneratedFiles/pendingQueue.csv")) {  //Checks if a pendingQueue.csv exists
            let csvData = await fs.readFile("master/autogeneratedFiles/pendingQueue.csv", 'utf8');
            let rows = csvData.split('\n');

            let rowOne = []; 
            let rowTwo = []; 

            rowOne = rows[1]; //We only need row 1 and 2, since row 0 is the header
            rowTwo = rows[2];

            if (rowOne !== undefined && rowOne !== '' && rowTwo !== undefined && rowTwo !== '') {
                pendingUserQueue = rowOne.split(',');           
                pendingTaskQueue = rowTwo.split(',');          
            }

        } else {
            await fs.writeFile("master/autogeneratedFiles/pendingQueue.csv", "", { encoding: 'utf8', flag: 'w' });
        }                   //If no pendingQueue.csv exists it creates an empty one
    } else {
        await fs.mkdir("master/autogeneratedFiles");
        await fs.writeFile("master/autogeneratedFiles/pendingQueue.csv", "", { encoding: 'utf8', flag: 'w' });
    }
}

async function loadFinishedQueue() {      
    if (existsSync("master/autogeneratedFiles")) {
        if (existsSync("master/autogeneratedFiles/finishedQueue.csv")) {  //Checks if a finishedQueue.csv exists
            let csvData = await fs.readFile("master/autogeneratedFiles/finishedQueue.csv", 'utf8');
            let rows = csvData.split('\n');

            let rowOne = []; 
            let rowTwo = []; 

            rowOne = rows[1]; //We only need row 1 and 2, since row 0 is the header
            rowTwo = rows[2];

            if (rowOne !== undefined && rowOne !== '' && rowTwo !== undefined && rowTwo !== '') { 
                finishedUserQueue = rowOne.split(',');          
                finishedTaskQueue = rowTwo.split(',');         
            }

        } else {
            await fs.writeFile("master/autogeneratedFiles/finishedQueue.csv", "", { encoding: 'utf8', flag: 'w' });
        }                   //If no finishedQueue.csv exists it creates an empty one
    } else {
        await fs.mkdir("master/autogeneratedFiles");
        await fs.writeFile("master/autogeneratedFiles/finishedQueue.csv", "", { encoding: 'utf8', flag: 'w' });
    }
}

async function pendingQueueToFinishedQueue(fileName) {    
    await loadPendingQueue();                    
    finishedUserQueue.push(await getUserQueueHead());
    finishedTaskQueue.push(fileName);
    await removeCustomerQueue();
    await saveFinishedQueue();
    await savePendingQueue();
}

async function getTaskByUser(user) {
    await loadPendingQueue();
    await loadFinishedQueue();
    let k = 0;
    let taskArrayForUser = [""];

    for (let i = 0; i < finishedUserQueue.length; i++) {
        if (user === finishedUserQueue[i]) {
            taskArrayForUser[k] = finishedTaskQueue[i];
            k++;
        }
    }

    taskArrayForUser[k] = "Shift";
    k++;

    for (let i = 0; i < pendingUserQueue.length; i++) {
        if (pendingUserQueue[i] == user) {
            taskArrayForUser[k] = pendingTaskQueue[i];
            k++;
        }
    }
    console.log(taskArrayForUser);
    return taskArrayForUser;
}

// Below functions only exported for testing is found

const getPendingUserQueue = () => pendingUserQueue;
const setPendingUserQueue = (value) => pendingUserQueue = value;

const getPendingTaskQueue = () => pendingTaskQueue;
const setPendingTaskQueue = (value) => pendingTaskQueue = value;

const getFinishedUserQueue = () => finishedUserQueue;
const setFinishedUserQueue = (value) => finishedUserQueue = value;

const getFinishedTaskQueue = () => finishedTaskQueue;
const setFinishedTaskQueue = (value) => finishedTaskQueue = value;

export const exportForTesting = {
    getPendingTaskQueue,
    setPendingTaskQueue,
    getPendingUserQueue,
    setPendingUserQueue,
    getFinishedTaskQueue,
    setFinishedTaskQueue,
    getFinishedUserQueue,
    setFinishedUserQueue
};