import { addWorker } from "./workerManagement.js";
import {getTaskQueueHead, pendingQueueToFinishedQueue} from "./queue.js";
export { assignWorkToWorker, enqueueTask, addToBeginningOfQueue, WorkerNode, taskCounter, storeSortedBuckets };

// Constants
const possibleValues = 1_000_000_000;

// Variables for the sorted tasks and merging
let taskCount = 0;
let sortedBuckets = [];

// Variables for the queue of tasks
let allTasks = [];
let availableTaskIndices = [];

let qHead;
let qTail;

function enqueueTask(taskIndex) {
    availableTaskIndices[qTail] = taskIndex;
    qTail = (qTail + 1) % availableTaskIndices.length + 1;
}

// In case a task fails, this task skips to the front of the queue.
function addToBeginningOfQueue(taskIndex) {
    qHead = (qHead - 1) % availableTaskIndices.length + 1;
    availableTaskIndices[qHead] = taskIndex;
}

function dequeueTask() {
    let task = availableTaskIndices[qHead];
    qHead = (qHead + 1) % availableTaskIndices.length + 1;
    return task;
}

async function assignWorkToWorker(workerUUID) {

    if (allTasks.length === 0) {
        allTasks = await taskSplitter(); // Change this await to whatever Vincent's cookin'
        availableTaskIndices = Array.from({length: allTasks.length + 1}, (_, i) => i);
        qHead = 0;
        qTail = availableTaskIndices.length;
    }

    if (qHead === qTail) {
        console.log("Completed sorting. ");
        addWorker(workerUUID, null);
        return null; // add some handling; if null is returned something is wrong.
    } else {
        let taskForWorker = dequeueTask();
        // Call a function here to add userID and sortTaskForWorker to a form of reservation list.
        addWorker(workerUUID, taskForWorker);
        return allTasks[taskForWorker];
    }
}

// call this function with: let workerX/ID/whatever = new WorkerNode(task)
class WorkerNode {
    //let currentTask;
    //let lastPing;

    constructor(task){
        this.currentTask = task;
        this.lastPing = new Date().getTime();
    }
}

// Put the sorted bucket into the correct position of the sortedBuckets array.
function storeSortedBuckets(bucket) {
    let indexForSortedBucket = Math.floor(bucket[0]/(possibleValues/allTasks.length));
    sortedBuckets[indexForSortedBucket] = bucket;
}


async function taskCounter(){
    taskCount++;
    if (taskCount >= allTasks.length) {
        await bucketConcatenate();
        taskCount = 0;
    }
}

async function bucketConcatenate() {
    let fileName = getTaskQueueHead();

    let outputFile = fs.open(`master/autogeneratedFiles/csv/sorted${fileName}.csv`, mode="w") //Note to self: figure out if I can hack a computer through this

    for(element of sortedBuckets){
        await outputFile.write(`${element},`); //Might be a good idea to do some buffer stuff if this is too slow
    }
    pendingQueueToFinishedQueue();
    allTasks = [];
    sortedBuckets = [];
}