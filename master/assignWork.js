import { addWorker } from "./workerManagement.js";
import { getTaskQueueHead, pendingQueueToFinishedQueue } from "./queue.js";
import { BucketList } from "./splitData.js";
import fs from "fs/promises";
import { existsSync, createWriteStream } from "fs";
export {
  assignWorkToWorker,
  enqueueTask,
  addToBeginningOfQueue,
  WorkerNode,
  taskCounter,
  storeSortedBuckets,
};

// Constants
const possibleValues = 1_000_000_000;

// Variables for the sorted tasks and merging
let taskCount = 0;
let sortedBuckets = [];
let fileCreated = false;
let outputFilePath;

// Variables for the queue of tasks
let allTasks = [];
let availableTaskIndices = [];

let qHead;
let qTail;
let fileLoad = false;

function enqueueTask(taskIndex) {
  availableTaskIndices[qTail] = taskIndex;
  qTail = (qTail + 1) % (allTasks.length + 1);
}

// In case a task fails, this task skips to the front of the queue.
function addToBeginningOfQueue(taskIndex) {
  qHead = qHead - 1 > 0 ? (qHead - 1) % (allTasks.length + 1) : 0;
  availableTaskIndices[qHead] = taskIndex;
}

function dequeueTask() {
  let task = availableTaskIndices[qHead];
  qHead = (qHead + 1) % (allTasks.length + 1);
  return task;
}
let startTime;

async function assignWorkToWorker(workerUUID) {
  if (fileLoad == false) {
    if (allTasks == null || allTasks.length === 0) {
      console.log("Getting current time: ");
      try{
        startTime = new Date().getTime();
        console.log(startTime);
      }
      catch(e) {
        console.log("Error getting time: " + e);
      }
      
      fileLoad = true;
      allTasks = await BucketList.fromQueue();
      fileLoad = false;
     // console.log(`All tasks:`);
      for (let i in allTasks) {
        console.log(`\t${i}: ${allTasks[i].length}`);
      }
      if (allTasks !== null) {
        availableTaskIndices = Array.from(
          { length: allTasks.length + 1 },
          (_, i) => i
        );
        qHead = 0;
        qTail = allTasks.length;
      } else {
        qHead = 0;
        qTail = 0;
      }
    }
  } else {
    qHead = 0;
    qTail = 0;
    console.log("File is being loaded in");
  }

  if (qHead === qTail) {
    console.log("No available tasks");
    addWorker(workerUUID, null);
    return null; // add some handling; if null is returned something is wrong.
  } else {
    let taskForWorker = dequeueTask();
    console.log(`Task for worker: ${taskForWorker}`);
    // Call a function here to add userID and sortTaskForWorker to a form of reservation list.
    addWorker(workerUUID, taskForWorker);
    return allTasks[taskForWorker];
  }
}

// call this function with: let workerX/ID/whatever = new WorkerNode(task)
class WorkerNode {
  currentTask;
  lastPing;

  constructor(task) {
    this.currentTask = task;
    this.lastPing = new Date().getTime();
  }
}

// Put the sorted bucket into the correct position of the sortedBuckets array.
/*function storeSortedBuckets(bucket) {
  let indexForSortedBucket = Math.floor(
    bucket[0] / (possibleValues / allTasks.length)
  );
  sortedBuckets[indexForSortedBucket] = bucket;
}*/

function storeSortedBuckets(bucket) { 
  if(!fileCreated) {
    fileCreated = true;
    let fileName = getTaskQueueHead();
    let outputFilePath = findUniqueName(fileName);
    outputFilePath = "sorted" + uniqueFileName;
  }

  writeBucketToFile()

}

async function taskCounter() {
  taskCount++;
  if (taskCount >= allTasks.length) {
    await bucketConcatenate();
    taskCount = 0;
  }
}

async function findUniqueName(filename) {
  if (existsSync("master/autogeneratedFiles/csvFiles/sorted" + filename)) {
    console.log("File already exists, creating new filename...");
    const pureFilename = filename.slice(0, filename.lastIndexOf(".")); // get filename without .csv extension
    for (let i = 1; i < 50; i++) {
      // arbitrary limit
      let newFileName = pureFilename + " (" + i + ")" + ".csv"; // similar to how windows handles duplicates, when downloading file
      if (
        !existsSync("master/autogeneratedFiles/csvFiles/sorted" + newFileName)
      )
        return `${newFileName}`;
    }
  } else {
    console.log("No duplicates detected");
    return `${filename}`;
  }
}

async function bucketConcatenate() {
  let fileName = await getTaskQueueHead();
  let uniqueFileName = await findUniqueName(fileName);
  uniqueFileName = "sorted" + uniqueFileName;

  console.log("Concat started");
  let concatTime = new Date().getTime();

  let outputFile = await fs.open(
    `master/autogeneratedFiles/csvFiles/${uniqueFileName}`,
    "w+"
  ); //Note to self: figure out if I can hack a computer through this
  
  let i = 0;
  for (let element of sortedBuckets) {
    console.log(i);
    await outputFile.write(`${element},`); //Might be a good idea to do some buffer stuff if this is too slow
    i++;
  }

  outputFile.close();
  console.log("Concat time: " + ((new Date().getTime() - concatTime)/1000))
  fs.unlink(`master/autogeneratedFiles/csvFiles/${fileName}`); // delete unsorted file when sorted file is done
  await pendingQueueToFinishedQueue(uniqueFileName);
  allTasks = [];
  sortedBuckets = [];
  console.log("Completed Sorting");
}

function getCharsForCSV(inputArray)
{
    let numberOfDigits = 0;
    for(let i = 0; i < inputArray.length; i ++) { // goes through every element, counts the elements digits and sums them all together
        numberOfDigits += Math.log(inputArray[i]) * Math.LOG10E + 1 | 0;
    }
    numberOfDigits += inputArray.length; // one comma for each number, and the last number has a newline, which is the same length
    return numberOfDigits;
}

function getBucketFileOffsets(allBuckets)
{
    let offsets = []
    let currentOffset = 0;

    offsets[0] = 0; // first bucket should obviously be placed at the start of the file.
    for(let i = 1; i < allBuckets.length; i++)
    {
        currentOffset += getCharsForCSV(allBuckets[i-1]);
        offsets[i] = currentOffset;
    }

    return offsets;
}

function writeBucketToFile(offset, bucket, filePath)
{
    console.log("Opening file!!!");
        fs.open(filePath, 'r+', function(err, fd) {
        if (err) throw err;
      
          const csvString = bucket.join(',') + '\n';
          const buffer = Buffer.from(csvString);
          fs.write(fd, buffer, 0, buffer.length, offset, function(err) {
            if (err) throw err;
          });
        console.log("Closing file!!!");
          fs.close(fd, function(err) {
            if (err) throw err;
          });
      
      });
}

// Below functions only exported for testing is found.
const getQueueHead = () => qHead;
const getQueueTail = () => qTail;
const getAllTasks = () => allTasks;
const getSortedBuckets = () => sortedBuckets;
const getPossibleValues = () => possibleValues;
const getAvailableTaskIndices = () => availableTaskIndices;

export const exportForTesting = {
  getQueueHead,
  getQueueTail,
  getAllTasks,
  getSortedBuckets,
  getPossibleValues,
  getAvailableTaskIndices,
  storeSortedBuckets,
  dequeueTask,
};
