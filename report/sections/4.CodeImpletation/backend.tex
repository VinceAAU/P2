\section{Backend}
In this section, the backend parts of the product will be described, that is, the parts of the program that are handled by the central server, including the login system, data splitting, and worker management. 

\subsection{File Upload}

File upload is mostly handled in the file \lstinline{exchangeData.js}. When a customer wishes to upload a file, the function \lstinline{handleUpload()} is called. This function calls \lstinline{downloadFile()} and then adds the file's name to the Customer Queue, described in Section \ref{ss:customerQueue}. The program receives files as HTTP form data, which is then parsed for the files, which are saved in the \lstinline{master/autogeneratedFiles/csvFiles} directory by the Formidable library. 
 
\subsection{Customer Queue} \label{ss:customerQueue}
The first queue system that is used is the Customer Queue. This is a queue that stores the names of the files that need processing, and the user that has requested its processing. The program stores this in the filesystem, to ensure that even if the master node needs to restart for some reason, the old Customer Queue can still be accessed, so work can resume as quickly as possible. The program uses two of these queues: A "pending queue" for the files that are either not processed yet, or are in the process of being processed, and a "finished queue" for files that have completed their processing.

The reasoning for using a customer queue rather than simply adding new files to the Task Queue is to avoid overwhelming the master's memory with several large files' worth of tasks.


\subsection{Task Splitter} \label{sub:taskSplitter}
When a worker node requests a task, and there are no tasks currently available for it, the master begins loading the first file in the Customer Queue and splitting it into buckets, which serve as tasks, as specified in Section \ref{sub:modelSplitData}.

The program then needs to figure out the optimal amount of buckets for the data, which is based on a target payload stored as a constant in the program. The program can then calculate the amount of buckets as:
\begin{equation*} 
\left \lceil{\frac{\text{Number of elements } \times \text{ Size of each element}}{\text{Target payload size}}}\right \rceil
\end{equation*}
The number of elements is estimated from the size of the input file, assuming that each element takes up 10 bytes in the CSV file on average (slightly off from the real average of 9.89 (3 s.f.)).

The data is then read in as a series of buffers, and each value received is stored into its corresponding bucket, as seen in Code \ref{lst:pushToBucket}. Because each buffer's border may be in the middle of a number, the last number of each buffer must be concatenated to the first number of the next buffer before it can be put into a bucket.

\begin{lstlisting}[caption=The part of the bucket sort code that puts the elements in a bucket., label=lst:pushToBucket] 
push(element){
  let bucketIndex = Math.floor(element/this.bucketInterval);

  if (this.buckets[bucketIndex] === undefined) {
      this.buckets[bucketIndex] = new Bucket(this.bucketSize);
      this.buckets[bucketIndex].push(element);
  } else {
      this.buckets[bucketIndex].push(element);
  }
}
\end{lstlisting}

When storing a large amount of data, the buckets become very large too. Normal JavaScript arrays are very inefficient and cause the master to run out of memory quickly, so therefore the choice was made to utilise \lstinline{Uint32Array}s for the buckets, which are much more compact. These arrays are wrapped in a \lstinline{Bucket} class, which contains the array and its current size. It is necessary to keep track of the current size of the array, as the program pre-allocates a certain amount of memory for it and the unused space is simply filled up with zeros, which could be mistaken for real data otherwise. When a value is pushed to the array with the \lstinline{push()} method, the value is put in at the \lstinline{size}th index, and \lstinline{size} is incremented by one. Once the entire data has been sorted into buckets, each of the buckets has its \lstinline{dezeroify()} method called, which truncates the array to \lstinline{size}. At that point, there is no reason to wrap the \lstinline{Uint32Array} in the \lstinline{Bucket} class anymore, so the return value is simply an array of \lstinline{Uint32Array}s (the buckets).


\subsection{Task Scheduler} \label{sss:taskQueue}
Each bucket is stored in an array called \lstinline{allTasks}, declared in the file \lstinline{assignWork.js}. Each bucket can then be referred to with its "task index", which is where it is stored in that array.

To decide which task to work on at a particular time, the task indices are stored as a queue, in another global variable, \lstinline{availableTaskIndices}, declared in the same file. There are then functions to enqueue and dequeue tasks as needed, described in Code \ref{lst:taskQueue}. There is also a function to add tasks to the beginning of the queue, in case the node previously working on that task fails, to give that task first priority. This isn't strictly necessary in the implementation, as the program specifically only works with one file at a time. However, if there were two files stored in the task queue, a node working with a task from the first file failed, and the task was re-enqueued normally, a customer would end up having to wait for the entire second file to finish processing before the first file can finish, as it has a single task at the tail of the queue. 

\begin{lstlisting} [caption=The enqueueTask and dequeueTask functions.,label=lst:taskQueue]
let qHead;
let qTail;

function enqueueTask(taskIndex) {
    availableTaskIndices[qTail] = taskIndex;
    qTail = (qTail + 1) % (allTasks.length + 1);
}

function dequeueTask() {
    let task = availableTaskIndices[qHead];
    qHead = (qHead + 1) % (allTasks.length + 1);
    return task;
}
\end{lstlisting}


\subsection{Communication between Task Scheduler and Workers}
A worker is expected to initiate the communication between it and the master. When it requests a task, the master will send one back to the worker in the form of an octet stream containing the numbers it needs to sort. These numbers are represented as an array of unsigned 32-bit integers (\lstinline{UInt32Array}), as the binary representation is much more compact than a text representation (such as JSON or CSV).

\subsection{Heartbeat System} \label{sub:backendHeartbeat}
When a grid computing system is public and can be used by anyone with internet access, it is unknown when someone will use it and for how long they will continue to give their computer's computational power to the system. Therefore, it is important to weed out any devices that may have disconnected from the system. For this, a heartbeat system was implemented. The worker sends a ping to the server every five seconds, which the server notes down. The server has a function, shown in Code \ref{lst:heartbeat} running in the background, which routinely iterates over all the different worker nodes, checking when they've last been contacted. If more time has passed than the specified timeout, the node is removed from the pool of active workers.

\begin{lstlisting} [caption=The heartbeat function., label=lst:heartbeat]
async function heartbeat(){
    while(true){
        for(let uuid in workers){
            if(uuid===undefined) continue;
            if(Date.now()-workers[uuid].lastPing > timeout){
                removeWorker(uuid);
            }
        }
        
        await new Promise(r => setTimeout(r, 5000));
    }
}
\end{lstlisting}


\subsection{Login System} \label{sec:backendLogin} 
To handle authentication and authorisation, a login system has been implemented. This ensures that only registered users are allowed to enter the worker or customer pages. 
To enhance the security and provide an optimal user experience, the login system has been made with the use of JSON Web Tokens (JWT). Figure \ref{fig:JWTOverview} provides an overview of how they are implemented.


\begin{figure}[H]
    \adjustbox{scale=0.75, center}{
        \begin{tikzpicture}[node distance=5cm, 
        component/.style={draw, text width=2cm, text centered, node distance=2cm}, important_component/.style={draw, text width=4cm, text centered}]
            %Client side
            \node [important_component] (Client) {Client Side};
            \node [component] (Loginform) [below of=Client]{Loginform from HTML};
            \node [component] (ReturnToken) [below of=Loginform, yshift=-3cm]{Return token for authentication};
            \node [component] (RederictMessage) [below of=ReturnToken, yshift=-4cm]{Redirect or error message};

            %Server side
            \node [important_component] (Server) [right of=Client, xshift=3cm] {Server side};
            \node [component] (AuthenticateLogin) [below of=Server, yshift=-1cm]{Authenti-cate login information};
            \node [component] (ReturnTokenOr403) [below of=AuthenticateLogin, yshift=-1cm]{Return token or HTTP 401 forbidden};
            \node[component] (ValidateToken) [below of=ReturnTokenOr403, yshift=-2cm]{validate token};
            \node[component] (Return201or403) [below of=ValidateToken] {Return 201 or 403};

            \draw [decoration={text along path,
            text={Username and Password},text align={center}},decorate]  ([yshift=0.1cm]Loginform.east) -- ([yshift=0.1cm]AuthenticateLogin.west);
            \draw[->]{(Loginform.east) -- (AuthenticateLogin.west)};

            \draw [decoration={text along path,
            text={201: Token or 401},text align={center}},decorate]  ([yshift=0.1cm]ReturnToken.east) -- ([yshift=0.1cm]ReturnTokenOr403.west);
            \draw[->]{(ReturnTokenOr403.west) -- (ReturnToken.east)};

            \draw [decoration={text along path,
            text={Token},text align={center}},decorate]  ([yshift=0.1cm]ReturnToken.east) -- ([yshift=0.1cm]ValidateToken.west);
            \draw[->]{(ReturnToken.east) -- (ValidateToken.west)};           

            \draw [decoration={text along path,
            text={201 or 403},text align={center}},decorate]  ([yshift=0.1cm]RederictMessage.east) -- ([yshift=0.1cm]Return201or403.west);
            \draw[->]{(Return201or403.west) -- (RederictMessage.east)};

            
        \draw[frame=33pt];
    \end{tikzpicture}
}
    \caption{An overview of the implementation of Json Web Tokens.}
    \label{fig:JWTOverview}
\end{figure}

An SQLite Database is used to store the credentials of the user. To interact with this database, the program uses the NodeJS package \lstinline{better-sqlite3}. The database contains a single table, with three columns storing the user's username, email, and password. The passwords are stored as bcrypt hashes. 


When a user logs onto the website and tries to access the "protected" sites, such as the worker and customer pages, the user will be prompted with a login page. When the login credentials are entered, and the user hits the login button, the credentials are passed to the server for validation, as depicted in Figure \ref{fig:JWTOverview}. 

When the credentials are received by the server, the database will be searched for the user with the specified username, as shown in Code \ref{SearchFunction}. 

\begin{lstlisting} [caption=Search database function., label={SearchFunction}]
async function search_db(searchUsername, searchPassword){
  const stmt = db.prepare('SELECT * FROM users WHERE username = ?').bind(searchUsername);
  const got = stmt.get(); 
  try{
    if(await bcrypt.compare(searchPassword, got.password)==true){ //function to unhash, with salt and compare with got.password
      return(searchUsername);
    }
    else {throw("wrong-password")}
  } catch {throw("no-user")}
};

\end{lstlisting}

If no user with said username is found, an error will be thrown. The password is then compared with the hash, and the function will return the username if the password is correct, and will throw an error if not. This is then passed on to the \lstinline{fetchUser} function in \lstinline{router.js}, which sends an appropriate HTTP response code back to the worker, i.e. 201 if an access token is created, or 401 if the credentials are incorrect. 

With the help of \lstinline{accessToken.js} initialized upon entering either the worker page or the customer page, an if statement is run to check the user's local storage, to see if an access token has been saved. If there is one, it will be fetched to the serverside for validation, and if successful the user will be allowed to access the protected site. If not, the user will be redirected back to the login section, before entering.