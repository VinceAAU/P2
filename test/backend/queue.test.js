import test from 'ava';
import { existsSync } from "fs";
import * as q from '../../master/queue.js';

let { 
    getPendingTaskQueue, 
    setPendingTaskQueue, 
    getPendingUserQueue, 
    setPendingUserQueue,
    getFinishedTaskQueue,
    setFinishedTaskQueue,
    getFinishedUserQueue,
    setFinishedUserQueue
} = q.exportForTesting;

test.serial('getUserQueueHead returns null on empty queue', async t=>{
    let userHead = await q.getUserQueueHead();
    t.is(userHead,null);
});

test.serial('getTaskQueueHead returns null on empty queue', async t=>{
    let taskHead = await q.getTaskQueueHead();
    t.is(taskHead,null);
});

test('getUserQueueHead returns head on non-empty array', async t=>{
    setPendingUserQueue(['exampleUser1', 'exampleUser2']);

    let userHead = await q.getUserQueueHead();
    t.is(userHead,'exampleUser1');
});

test('getTaskQueueHead returns head on non-empty array', async t=>{
    setPendingTaskQueue(['example1.csv', 'example2.csv']);

    let taskHead = await q.getTaskQueueHead();
    t.is(taskHead,'example1.csv');
});

test('removeFinishedCustomerQueue removes at correct index', async t=>{
    setFinishedUserQueue(['exampleUser1', 'exampleUser2', 'exampleUser3']);
    setFinishedTaskQueue(['example1.csv', 'example2.csv', 'example3.csv']);
    
    await q.removeFinishedCustomerQueue(1);

    let tFinishedUserQueue = getFinishedUserQueue();
    let tFinishedTaskQueue = getFinishedTaskQueue();

    t.deepEqual(tFinishedUserQueue, ['exampleUser1','exampleUser3']);
    t.deepEqual(tFinishedTaskQueue, ['example1.csv','example3.csv']);
    
    await q.removeFinishedCustomerQueue(0); //Needed to clear out the finishedQueue
    await q.removeFinishedCustomerQueue(0); //so that other tests work
});

test('findFinishedTaskIndex returns null if no matching index is found', async t=>{
    setFinishedUserQueue(['exampleUser1', 'exampleUser2', 'exampleUser3']);
    setFinishedTaskQueue(['example1.csv', 'example2.csv', 'example3.csv']);

    let index = await q.findFinishedTaskIndex('exampleUser2', 'example1.csv');

    t.is(index,null);

});

test('findFinishedTaskIndex finds correct index', async t=>{
    setFinishedUserQueue(['exampleUser1', 'exampleUser2', 'exampleUser3']);
    setFinishedTaskQueue(['example1.csv', 'example2.csv', 'example3.csv']);

    let index = await q.findFinishedTaskIndex('exampleUser2', 'example2.csv');

    t.is(index,1);
});


test('serverDownloadCsv downloads with correct placement', async t=>{
    let data = [''];
    let csvFileName = 'pendingQueue';

    await q.serverDownloadCsv(data, csvFileName);

    t.assert(existsSync('master/autogeneratedFiles/pendingQueue.csv'));
});


test('csvMaker makes expected csv format', async t=>{
    let pendingQueueData = {
        User: ['exampleUser1','exampleUser2'],
        Task: ['example1.csv','example2.csv']
    };

    let csvData = await q.csvMaker(pendingQueueData);
    let correctFormat = "User,Task\nexampleUser1,exampleUser2\nexample1.csv,example2.csv";

    t.is(csvData,correctFormat);
});

test.serial('getTaskByUser gets all correct tasks', async t=>{
    setFinishedUserQueue(['exampleUser1', 'exampleUser1', 'exampleUser3']);
    setFinishedTaskQueue(['example1.csv', 'example2.csv', 'example3.csv']);
    setPendingUserQueue(['exampleUser1', 'exampleUser2', 'exampleUser3']);
    setPendingTaskQueue(['example1.csv', 'example2.csv', 'example3.csv']);

    let arrayForUser = await q.getTaskByUser('exampleUser1');
    let correctArray = ['example1.csv', 'example2.csv', 'Shift', 'example1.csv'];

    t.deepEqual(arrayForUser, correctArray);
});